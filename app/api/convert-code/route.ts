import { type NextRequest, NextResponse } from "next/server"
import { getUserFromAuthHeader } from "@/lib/auth-server"
import { supabaseServer } from "@/lib/supabase/server"
import { v4 as uuidv4 } from "uuid"

export async function POST(request: NextRequest) {
  try {
    console.log("üîÑ Convert code API called")

    // Check authentication
    const authHeader = request.headers.get("authorization")
    if (!authHeader) {
      console.error("‚ùå No authorization header")
      return NextResponse.json({ error: "Authorization header required" }, { status: 401 })
    }

    const user = await getUserFromAuthHeader(authHeader)
    if (!user) {
      console.error("‚ùå Invalid user from auth header")
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    console.log("‚úÖ User authenticated:", user.id)

    // Get Google API key from headers
    const googleApiKey = request.headers.get("X-Google-API-Key")
    console.log("üîë API Key Debug:", {
      hasKey: !!googleApiKey,
      keyLength: googleApiKey?.length,
      keyPrefix: googleApiKey?.substring(0, 5),
    })

    if (!googleApiKey) {
      console.error("‚ùå No Google API key in headers")
      return NextResponse.json({ error: "Google API key required" }, { status: 400 })
    }

    const body = await request.json()
    const { code, fromLanguage, fromFramework, target, threadId, messageId } = body

    if (!code || !target) {
      console.error("‚ùå Missing code or target:", { hasCode: !!code, hasTarget: !!target })
      return NextResponse.json({ error: "Code and target are required" }, { status: 400 })
    }

    console.log("üîÑ Converting code:", {
      fromLanguage,
      fromFramework,
      targetLanguage: target.language,
      targetFramework: target.framework,
      codeLength: code.length,
    })

    // Create the actual conversion prompt
    const fromDescription = fromFramework ? `${fromLanguage} (${fromFramework})` : fromLanguage
    const toDescription = target.framework ? `${target.language} (${target.framework})` : target.language

    const conversionPrompt = `Convert the following ${fromDescription} code to ${toDescription}.

Requirements:
- Maintain the exact same functionality and logic
- Use proper syntax for ${toDescription}
- Include necessary imports/headers if needed
- Keep the same structure and flow
- Add brief comments only where absolutely necessary
- Return ONLY the converted code, no explanations or markdown

Original ${fromDescription} code:
${code}

Converted ${toDescription} code:`

    console.log("ü§ñ Sending conversion request to Google API...")

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${googleApiKey}`

    const payload = {
      contents: [
        {
          parts: [
            {
              text: conversionPrompt,
            },
          ],
        },
      ],
      generationConfig: {
        temperature: 0.1, // Low temperature for consistent code conversion
        maxOutputTokens: 4000,
        topP: 0.8,
        topK: 10,
      },
    }

    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    })

    console.log("üì° Google API Response:", {
      status: response.status,
      statusText: response.statusText,
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error("‚ùå Google API Error Response:", errorText)

      if (response.status === 400) {
        return NextResponse.json(
          { error: "Invalid Google API key or request. Please check your API key in Settings." },
          { status: 400 },
        )
      }

      if (response.status === 429) {
        return NextResponse.json({ error: "API quota exceeded. Please try again later." }, { status: 429 })
      }

      return NextResponse.json({ error: `Google API error: ${response.statusText}` }, { status: response.status })
    }

    const result = await response.json()
    console.log("‚úÖ Google API Success")

    // Extract the generated text
    const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text

    if (!generatedText) {
      console.error("‚ùå No generated text in response:", result)
      return NextResponse.json({ error: "No code generated by AI" }, { status: 500 })
    }

    console.log("üéØ Generated code preview:", generatedText.substring(0, 100) + "...")

    // Clean up the response - remove any markdown code blocks if present
    let cleanedCode = generatedText.trim()

    // Remove markdown code blocks if they exist
    const codeBlockRegex = /^```[\w]*\n([\s\S]*?)\n```$/
    const match = cleanedCode.match(codeBlockRegex)
    if (match) {
      cleanedCode = match[1].trim()
      console.log("üßπ Removed markdown code blocks")
    }

    // Remove any leading/trailing explanatory text
    const lines = cleanedCode.split("\n")
    const codeLines = lines.filter((line: string) => {
      const trimmed = line.trim()
      return (
        trimmed &&
        !trimmed.startsWith("Here") &&
        !trimmed.startsWith("The converted") &&
        !trimmed.startsWith("This code") &&
        !trimmed.toLowerCase().includes("equivalent")
      )
    })

    const finalCode = codeLines.join("\n").trim()

    console.log("‚ú® Final converted code:", {
      originalLength: code.length,
      convertedLength: finalCode.length,
      target: target.label,
    })

    // Save the conversion to the database if threadId and messageId are provided
    let conversionId = null
    if (threadId && messageId) {
      // Always generate a new UUID for each conversion
      conversionId = uuidv4()

      console.log("üíæ Saving conversion to database with ID:", conversionId)
      
      const conversionData = {
        id: conversionId,
        thread_id: threadId,
        message_id: messageId,
        user_id: user.id,
        original_code: code,
        original_language: fromLanguage,
        converted_code: finalCode,
        target_language: target.label,
        created_at: new Date().toISOString()
      }

      const { error: saveError } = await supabaseServer
        .from("code_conversions")
        .insert(conversionData)

      if (saveError) {
        console.error("‚ùå Error saving code conversion:", saveError)
        console.error("Failed conversion data:", {
          id: conversionId,
          thread_id: threadId,
          message_id: messageId,
          user_id: user.id,
          original_language: fromLanguage,
          target_language: target.label,
          code_length: code.length,
          converted_length: finalCode.length
        })
        // Continue even if saving fails
      } else {
        console.log("‚úÖ Successfully saved conversion to database")
        
        // Double-check that the conversion was saved
        const { data: checkData, error: checkError } = await supabaseServer
          .from("code_conversions")
          .select("id")
          .eq("id", conversionId)
          .single()
          
        if (checkError) {
          console.error("‚ùå Error verifying saved conversion:", checkError)
        } else {
          console.log("‚úÖ Verified conversion saved with ID:", checkData.id)
        }
      }
    }

    return NextResponse.json({
      convertedCode: finalCode,
      target: target.label,
      id: conversionId,
    })
  } catch (error) {
    console.error("‚ùå Code conversion error:", error)

    if (error instanceof Error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ error: "Conversion failed" }, { status: 500 })
  }
}
